## Problema

8 - Considera a seguinte classe:

```cs
public abstract class NPC
{
    public float HP { get; protected set; }

    public NPC(float hp)
    {
        HP = hp;
    }

    public void PlayTurn()
    {
        if (FindEnemies())
        {
            AttackEnemies();
        }
        if (FindFood())
        {
            EatFood();
        }
        Move();
    }

    protected abstract bool FindFood();
    protected abstract bool FindEnemies();
    protected abstract void EatFood();
    protected abstract void AttackEnemies();

    protected virtual void Move()
    {
        Console.WriteLine(this.GetType() + " has moved!");
    }
}
```

Responde às seguintes questões (aceitam-se soluções parciais):

1.  É possível instanciar esta classe? Porquê?
2.  É possível estender esta classe? Porquê?
3.  Que métodos desta classe podem ser sobrepostos (_overridden_)? Porquê?
4.  Que métodos desta classe **não** podem ser sobrepostos (_overridden_)?
    Porquê?
5.  Cria pelo menos 3 subclasses concretas (não abstratas), representando
    diferentes NPCs num jogo, com lógicas concretas e específicas para cada um
    deles. Os métodos `EatFood()` e `AttackEnemies()` podem consistir apenas de
    `Console.WriteLines`.
6.  Identifica a presença de polimorfismo na solução que apresentaste no ponto
    anterior.
7.  Cria uma classe `Program` com um método `Main()` para testar as classes
    criadas no ponto anterior. Por exemplo, criar uma ou mais instâncias de cada
    classe, colocar as mesmas numa coleção de `NPC`, percorrer a coleção, e
    invocar o método `PlayTurn()` em cada uma delas. Repara que, além do
    construtor, só o método `PlayTurn()` pode ser invocado a partir de outras
    classes.
8.  Desenha o diagrama UML da solução apresentada.
9.  Esta estrutura de classes corresponde a um _design pattern_ muito útil e
    comum, que consiste em definir os passos principais de um algoritmo ou
    operação, delegando nas subclasses alguns ou todos os passos concretos do
    mesmo. Por outras palavras, este _design pattern_ permite redefinir alguns
    passos do algoritmo ou operação sem alterar a estrutura do mesmo. Que
    _design pattern_ é este?

## Soluções

### Solução 1

1. Não, pois uma classe abstrata é feita para ser uma classe base.

2. Sim, desde que se faça um override com uma subclasse.

3. O _FindFood_, _FindEnemies_ e _EatFood_ , pois são _abstract_ e foram feitos para serem alterados

4. O _HP_ e _hp_, pois são propriedades.

5. 
```cs
public class Ork : NPC
{
    int food = 0;
    int player_health = 10;

    public override bool FindFood(){
        food++;
    }

    public override bool FindEnemies(){
        Move();
    }

    public override void Move()
    {
        Console.WriteLine(this.GetType() + " has moved!");
        AttackEnemies();
    }
    public override void AttackEnemies(){
        player_health--;
        Console.WriteLine(this.GetType() + " has attacked!");
    }
    public override void EatFood(){
        Console.WriteLine(this.GetType() + " has eaten!")
        food --;
    }
}


public class Goblin : NPC
{
    int food = 0;
    int player_health = 10;

    public override bool FindFood(){
        food++;
        Console.WriteLine(this.GetType() + " celebrates.");
        EatFood();
    }

    public override void EatFood(){
        Console.WriteLine(this.GetType() + " has eaten!");
        food --;
        FindEnemies();
    }

    public override bool FindEnemies(){
        AttackEnemies();
    }
    public override bool AttackEnemies(){
        Console.WriteLine(this.GetType() + " attacked!");
        Move();
    }

    public override void Move()
    {
        Console.WriteLine(this.GetType() + " escaped!");
    }
}

public class Dragon : NPC
{
    int food = 0;
    int player_health = 10;


    public override void FindEnemies(){
        Console.WriteLine(this.GetType() + " has found you!");
            }

    public override void Move()
    {
        Console.WriteLine(this.GetType() + " has moved!");
        AttackEnemies();
    }

    public override void AttackEnemies(){
        Console.WriteLine(this.GetType() + " has attacked!");
        player_health -= 10000;
        FindFood();

    }

    public override void FindFood(){
        food++; 
        EatFood();  
    }

    public override void EatFood(){
        Console.WriteLine(this.GetType() + " has eaten!")
        food --;
    }
}
```

6. Existem nos casos _FindFood_ , _EatFood_ , _FindEnemies_ , _AttackEnemies_ e _Move_ pois é perciso aplicar _override_ obrigatóriamente a classes _abstract_, mas pode-se aplicar a classes _virtual_ se o utilizador quiser.

7. 
```cs
class Program
    {
        static void Main(string[] args)
        {
            List<NPC> npc = new List<NPC>();
            Dragon dr = new Dragon(100);
            Ork ork = new Ork(20);
            Goblin gbln = new Goblin(5);
            npc.Add(dr);
            npc.Add(ork);
            npc.Add(gbln);
            foreach(NPC n in npc)
            {
                n.PlayTurn();
            }

        }
    }

public abstract class NPC
    {
        public float HP { get; protected set; }

        public NPC(float hp)
        {
            HP = hp;
        }

        public void PlayTurn()
        {
            if (FindEnemies())
            {
                AttackEnemies();
            }
            if (FindFood())
            {
                EatFood();
            }
            Move();
        }

        protected abstract bool FindFood();
        protected abstract bool FindEnemies();
        protected abstract void EatFood();
        protected abstract void AttackEnemies();

        protected virtual void Move()
        {
            Console.WriteLine(this.GetType() + " has moved!");
        }
    }

public class Goblin : NPC
    {
        int food = 0;

        public Goblin(float hp) : base(hp)
        {
            HP = hp;
        }

        protected override bool FindFood()
        {
            food++;
            Console.WriteLine(this.GetType() + " celebrates.");
            EatFood();
            return true;
        }

        protected override void EatFood()
        {
            Console.WriteLine(this.GetType() + " has eaten!");
            food --;
            FindEnemies();
        }

        protected override bool FindEnemies()
        {
            AttackEnemies();
            return true;
        }
        protected override void AttackEnemies()
        {
            Console.WriteLine(this.GetType() + " attacked!");
            Move();

        }

        protected override void Move()
        {
            Console.WriteLine(this.GetType() + " escaped!");
        }
    }

public class Ork : NPC
    {
        int food = 0;
                
        public Ork(float hp):base(hp)
        {
            HP = hp;
        }

        protected override bool FindFood()
        {
            food++;
            return true;
        }

        protected override bool FindEnemies()
        {
            Move();
            return true;
        }

        protected override void Move()
        {
            Console.WriteLine(this.GetType() + " has moved!");
            AttackEnemies();
        }
        protected override void AttackEnemies()
        {
            HP--;
            Console.WriteLine(this.GetType() + " has attacked!");
        }
        protected override void EatFood()
        {
            Console.WriteLine(this.GetType() + " has eaten!");
            food --;
        }
    }


public class Dragon : NPC
    {
        int food = 0;
        int hp = 10;

        public Dragon(float hp) : base(hp)
        {
            HP = hp;
        }

        protected override bool FindEnemies()
        {
            Console.WriteLine(this.GetType() + " has found you!");
            Move();
            return true;
        }

        protected override void Move()
        {
            Console.WriteLine(this.GetType() + " has moved!");
            AttackEnemies();
        }

        protected override void AttackEnemies()
        {
            Console.WriteLine(this.GetType() + " has attacked!");
            hp -= 10000;
            FindFood();

        }

        protected override bool FindFood()
        {
            food++;
            EatFood();
            return true;
        }

        protected override void EatFood()
        {
            Console.WriteLine(this.GetType() + " has eaten!");
            food --;
        }
    }
```

8. https://i.imgur.com/4lPiWJy.jpg

9. Diagrama de classes.

_Hugo Martins_  