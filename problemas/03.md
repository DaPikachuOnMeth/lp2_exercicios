# Estruturas de Dados / Coleções

1 - Quais as diferenças entre as
[coleções não-genéricas](https://docs.microsoft.com/dotnet/api/system.collections)
e as
[coleções genéricas](https://docs.microsoft.com/dotnet/api/system.collections.generic)
no C#? Quais as vantagens destas últimas?

> [Soluções](../solucoes/03/001.md)

---

2 - O C# providencia um conjunto bastante completo de
[coleções genéricas](https://docs.microsoft.com/dotnet/api/system.collections.generic).
Algumas das mais usadas são as que se seguem:

*   [`List<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1)
*   [`Queue<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1)
*   [`Stack<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1)
*   [`HashSet<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1)
*   [`Dictionary<TKey,TValue>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.dictionary-2)

Responde às seguintes questões:

1.  Qual a interface genérica comum a todas estas coleções? Que comportamento
    ficam as classes obrigadas a ter devido a implementarem essa interface?
2.  Explica sucintamente como estas coleções funcionam e dá exemplos onde cada
    uma seja especialmente útil.
3.  Além das coleções mencionadas, existem mais coleções genéricas no
    _namespace_
    [System.Collections.Generic](https://docs.microsoft.com/dotnet/api/system.collections.generic).
    Dá o exemplo de uma, explica sucintamente como funciona e dá um exemplo
    onde a mesma possa ser especialmente útil.

> [Soluções](../solucoes/03/002.md)

---

3 - Escreve um método `static` que inicialize e devolva uma
[lista genérica](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1)
contendo _n_ cópias de um valor passado como parâmetro e tipo especificado como
argumento genérico.

> [Soluções](../solucoes/03/003.md)

---

4 - Considera a seguinte classe:

```cs
public class Weapon
{
    public float AttackPower { get; }
    public float Durability { get; }

    public Weapon(float attackPower, float durability)
    {
        AttackPower = attackPower;
        Durability = durability;
    }
}
```

Assume que temos uma lista de armas, ou seja, uma variável do tipo
`List<Weapon>` e responde às seguintes questões:

1.  Faz as alterações necessárias à classe `Weapon` de modo a que quando
    invocarmos o método
    [`Sort`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort)
    (ou mais concretamente, o seu
    [_overload_ sem parâmetros](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort))
    da classe `List<T>`, as instâncias de `Weapon` fiquem ordenadas por
    `AttackPower` decrescente. _Sugestão:_ a classe `Weapon` tem de implementar
    [`IComparable<T>`](https://docs.microsoft.com/dotnet/api/system.icomparable-1).
2.  Cria uma classe `Program` com um método `Main()` para testar uma lista de
    várias instâncias de `Weapon`, nomeadamente a sua ordenação por
    `AttackPower` decrescente usando o método
    [`Sort()`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort)
    sem parâmetros.
3.  O método
    [`Sort`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort)
    da classe `List<T>` tem vários _overloads_. Um deles,
    [`Sort(IComparer<T>)`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort_System_Collections_Generic_IComparer__0__),
    permite ordenar a lista usando o critério de ordenação definido numa classe
    extra. Tal classe, como indicado na assinatura do método, tem de
    implementar a interface
    [`IComparer<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.icomparer-1).
    Cria uma classe deste tipo cujo critério de ordenação seja `Durability`
    crescente.  
4.  Adiciona ao método `Main()` da classe `Program` um teste à ordenação
    por `Durability` crescente usando o método
    [`Sort(IComparer<T>)`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1.sort#System_Collections_Generic_List_1_Sort_System_Collections_Generic_IComparer__0__)
    e a classe desenvolvida no ponto anterior.

> [Soluções](../solucoes/03/004.md)

---

5 - A API do C# contém uma coleção especializada na manipulação de booleanos
(zeros e uns). Faz uma pesquisa para descobrires que coleção é essa e realça
algumas das suas principais funcionalidades, nomeadamente vantagens sobre o uso
de um simples _array_ de booleanos.

> [Soluções](../solucoes/03/005.md)

---

6 - Cria a classe genérica `AwesomeList<T>` que estende
[`List<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1)
e faz `override` do método `ToString()` de modo que a devolva uma _string_ que
indique o número de elementos na lista bem como o tipo desses elementos.

_Nota:_ pode ser necessário recorrer ao operador
[`typeof`](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/typeof)
para obter o tipo de `T`.

> [Soluções](../solucoes/03/006.md)

---

7 - Dá três exemplos de coleções genéricas do C# que implementem
[`ICollection<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.icollection-1).
Qual é ou quais são as funcionalidades que as coleções que implementam esta
interface são obrigadas a ter?

> [Soluções](../solucoes/03/007.md)

---

8 - Considera as interfaces
[`IList<T>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.ilist-1)
e
[`IDictionary<TKey,TValue>`](https://docs.microsoft.com/dotnet/api/system.collections.generic.idictionary-2)
.

1.  Para cada uma das interfaces, dá um exemplo de uma coleção do C# que a
    implemente.
2.  Qual é ou quais são as funcionalidades que as coleções que implementam
    estas interfaces são obrigadas a ter?

> [Soluções](../solucoes/03/008.md)

---

9 - Indica três coleções da API do C# que suportem sintaxe de inicialização de
coleções e dá um exemplo de uso para cada uma delas.

> [Soluções](../solucoes/03/009.md)

---

10 -  Considera os tipos `MonsterType` e `Monster`, definidos pelo seguinte
código:

```cs
enum MonsterType { Troll, Ogre, Elf, Demon }
```

```cs
class Monster
{
    public const double maxHealth = 100;
    public const int maxStrength = 200;
    public MonsterType Type { get; set; }
    public double Health { get; set; }
    public int Strength { get; set; }
}
```

Responde às seguintes questões:

1.  Existe algum campo `static` (de classe) na classe `Monster`?
2.  Adiciona o método iterável `CreateRandomMonsters()` à classe `Monster`, que
    recebe um inteiro _n_ indicando quantos monstros devem ser criados, e que
    devolve um `IEnumerable<Monster>` de _n_ monstros com campos inicializados
    aleatoriamente (dentro dos limites especificados nos tipos).
3.  O método `CreateRandomMonsters()` deve ser `static`? Justifica a tua
    resposta.
4.  Faz _override_ do método `ToString()` na classe `Monster` de modo a que o
    mesmo devolva uma _string_ indicando, de forma bem formatada, as várias
    propriedades do monstro. Por exemplo, a propriedade `Health` não deve ter
    mais de duas casas decimais.
4.  Cria a classe `Program` com um método `Main` para testares a criação de 20
    monstros aleatórios com o método `CreateRandomMonsters()`, imprimindo no
    ecrã a _string_ devolvida pelo método `ToString()` para cada monstro.

> [Soluções](../solucoes/03/010.md)

---

11 - ...

> [Soluções](../solucoes/03/011.md)

---

12 - ...

> [Soluções](../solucoes/03/012.md)

---

13 - ...

> [Soluções](../solucoes/03/013.md)

---

14 - ...

> [Soluções](../solucoes/03/014.md)

---

15 - ...

> [Soluções](../solucoes/03/015.md)
